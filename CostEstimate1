#Plethora Coding Exercise
#A. Benjamin Falk

#PROBLEMS RIGHT NOW: 
#     Probably doesn't work for off axis (diagonal) curves
#place .json file into memory
#syntax: where both userDirectory and filename are strings, editable in Main()
from collections import OrderedDict    
import math
import json 

def PlaceIntoMemory(userDirectory, filename):
    with open(userDirectory+filename) as data_file:
        global data
        data = json.load(data_file, object_pairs_hook = OrderedDict)
    global EdgesArray
    EdgesArray =[]       
    for key in data['Edges']:
        EdgesArray.append(key)
    global numEdges
    numEdges = len(EdgesArray)
    
    global AllVerticesArray
    AllVerticesArray=[]
    for key in data['Vertices']:
        AllVerticesArray.append(key)
    global numVertices
    numVertices = len(AllVerticesArray) 

def Initialize():                                                                # alot of globals since I made an intialize function
    global padding                                                               # instead of just declaring variables
    padding = .1
    global materialCost
    materialCost = .75
    global maxSpeed
    maxSpeed = .5
    global cuttingTimeCost
    cuttingTimeCost = .07
    global straightCuttingCost
    straightCuttingCost = 0
    global arcCuttingCost
    arcCuttingCost = 0
    global addedArea
    addedArea = 0
    arcInside = False
    straightedgeVertices = {}
    arcedgeVertices = {}
    
class Edge(object):
    def __init__(self,EdgeId,EdgeType):
        self.EdgeID = EdgeId
        self.EdgeType = EdgeType
    def isArc(self,EdgeType):
        if EdgeType == "LineSegment":
            return False
        else:
            return True       
    def getVertices(self):
        return data['Edges'][self.EdgeID]['Vertices'] 
    def getArcCenter(self):
        return data['Edges'][self.EdgeID]['Center']
    def getArcDirection(self):
        return data['Edges'][self.EdgeID]['ClockwiseFrom']
    
class Vertice(object):   
    def __init__(self,VerticeID):
        self.VerticeID = VerticeID    
    def getXcoord(self):
        return data['Vertices'][self.VerticeID]['Position']['X']
    def getYcoord(self):
        return data['Vertices'][self.VerticeID]['Position']['Y']
    
def FindDistances():   
    for i in range(numEdges):
        myEdge = Edge(EdgesArray[i],data['Edges'][EdgesArray[i]]['Type'])
        if myEdge.isArc(myEdge.EdgeType) == False:
            global straightedgeVertices
            straightedgeVertices = {'x1': data['Vertices'][str(myEdge.getVertices()[0])]['Position']['X'], 
                      'y1': data['Vertices'][str(myEdge.getVertices()[0])]['Position']['Y'], 
                      'x2': data['Vertices'][str(myEdge.getVertices()[1])]['Position']['X'],
                      'y2': data['Vertices'][str(myEdge.getVertices()[1])]['Position']['Y']}
            straightdistance = math.sqrt((straightedgeVertices['x2']-straightedgeVertices['x1'])**2 + (straightedgeVertices['y2'] - straightedgeVertices['y1'])**2)
            global straightCuttingCost
            straightCuttingCost += (straightdistance/maxSpeed)*cuttingTimeCost
        else:
            global arcedgeVertices
            arcedgeVertices = {'x1': data['Vertices'][str(myEdge.getVertices()[0])]['Position']['X'], 
                      'y1': data['Vertices'][str(myEdge.getVertices()[0])]['Position']['Y'], 
                      'x2': data['Vertices'][str(myEdge.getVertices()[1])]['Position']['X'],
                      'y2': data['Vertices'][str(myEdge.getVertices()[1])]['Position']['Y']}
            global radius
            if (myEdge.getArcCenter()['X'] == arcedgeVertices['x1']) and (myEdge.getArcCenter()['X'] == arcedgeVertices['x2']):
                radius = myEdge.getArcCenter()['Y']
            if (myEdge.getArcCenter()['Y'] == arcedgeVertices['y1']) and (myEdge.getArcCenter()['Y'] == arcedgeVertices['y2']):
                radius = myEdge.getArcCenter()['X']
            arcDirectionVertice = {'x': data['Vertices'][str(myEdge.getArcDirection())]['Position']['X'],
                        'y': data['Vertices'][str(myEdge.getArcDirection())]['Position']['Y']}
            print(myEdge.getVertices()[0])
            print(myEdge.getArcDirection())
            if myEdge.getVertices()[0] == myEdge.getArcDirection():
                arcInside = True 
            else:
                arcInside = False
                
            if arcInside == False:
                global addedArea
                addedArea += radius * ((radius*2)+padding)                        #assuming the arcs must go from vertice to vertice
                    
            arcdistance = radius*math.pi
            arcCuttingSpeed = maxSpeed*math.exp(-1/radius)
            global arcCuttingCost
            arcCuttingCost += (arcdistance/arcCuttingSpeed)*cuttingTimeCost
            
def FindArea(X,Y,numPoints):
    area = 0
    j = numPoints-1
    for i in range(numPoints):
        area += (X[j]+X[i])*(Y[j]-Y[i])
        j = i
    if area < 0:
        return area/-2                                                           # -2 or 2 based on whether the points in coordinate 
    else:                                                                        # lists are in clockwise or counterclockwise order
        return area/2
    
def Main():
    myDirectory = 'C:\\Users\\falka\\python files\\'
    filename = 'RightTriangle.json'
    PlaceIntoMemory(myDirectory,filename) 
    Initialize()
    FindDistances()
    Xcoords=[]
    Ycoords=[]
    for i in range(numVertices):
        MyVertice = Vertice(AllVerticesArray[i])
        Xcoords.append(MyVertice.getXcoord())
        Ycoords.append(MyVertice.getYcoord())
    
    for i in range(numVertices):
        if Xcoords[i] != 0:
            Xcoords[i] += padding
        if Ycoords[i] != 0:
            Ycoords[i] += padding
            
    iniArea = FindArea(Xcoords,Ycoords,numVertices)
    finalArea = iniArea+addedArea
    Areacost = finalArea*materialCost
    finalCost = Areacost+straightCuttingCost+arcCuttingCost
    print("%.2f" %finalCost + " dollars")
        
Main()
